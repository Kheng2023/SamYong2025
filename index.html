<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Center Location Analysis - Australia</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 20px rgba(0,0,0,0.1);
        }

        .main-content {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 24px;
            text-align: center;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .section h3 {
            color: #34495e;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .upload-area {
            border: 2px dashed #3498db;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background-color: rgba(52, 152, 219, 0.1);
        }

        .upload-area.dragover {
            border-color: #27ae60;
            background-color: rgba(46, 204, 113, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .layer-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
        }

        .layer-control input[type="checkbox"] {
            margin-right: 10px;
        }

        .layer-control input[type="range"] {
            margin-left: auto;
            width: 80px;
        }

        .analysis-results {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid #27ae60;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-width: 300px;
            z-index: 1000;
        }

        .score-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            margin-left: 10px;
        }

        .score-high { background-color: #27ae60; }
        .score-medium { background-color: #f39c12; }
        .score-low { background-color: #e74c3c; }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }

        /* Custom marker styles */
        .custom-marker {
            border: none !important;
            background: none !important;
        }

        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Layer toggle improvements */
        .layer-control {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .layer-control input[type="checkbox"]:checked + label {
            font-weight: bold;
            color: #2c3e50;
        }

        /* Legend styles */
        .legend-container {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 0;
            font-size: 14px;
        }

        .legend-item:not(:last-child) {
            border-bottom: 1px solid #eee;
        }

        /* Weight control styling */
        .weight-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
        }

        .weight-control label {
            flex: 1;
            font-size: 12px;
            font-weight: bold;
        }

        .weight-control input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }

        .weight-control span {
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üè¢ Data Center Heatmap Analysis</h1>
            
            <div class="section">
                <h3>üìä Specialized Data Loading</h3>
                
                <button class="btn" onclick="loadDataCenterData()" style="background: #27ae60; color: white; margin-bottom: 10px;">
                    üîç Load Data Center Analysis Data
                </button>
                
                <button class="btn" onclick="resetMap()" style="background: #dc3545; color: white;">
                    üóëÔ∏è Reset Map
                </button>
                
                <div id="data-loading-status" style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 5px; display: none;">
                    <h4 style="margin: 0 0 5px 0;">Loading Progress:</h4>
                    <div id="loading-details"></div>
                </div>
            </div>

            <div class="section">
                <h3>üé® Data Categories</h3>
                <div class="legend-container">
                    <div class="legend-item">
                        <span style="color: #3498db; font-size: 16px;">üë• ‚óè</span>
                        <span>User Demographics</span>
                    </div>
                    <div class="legend-item">
                        <span style="color: #9b59b6; font-size: 16px;">üåê ‚ñ†</span>
                        <span>Network Infrastructure</span>
                    </div>
                    <div class="legend-item">
                        <span style="color: #f39c12; font-size: 16px;">‚ö° ‚ñ≤</span>
                        <span>Energy Grid</span>
                    </div>
                    <div class="legend-item">
                        <span style="color: #2ecc71; font-size: 16px;">üîã ‚ô¶</span>
                        <span>Renewable Energy</span>
                    </div>
                    <div class="legend-item">
                        <span style="color: #1abc9c; font-size: 16px;">üå°Ô∏è ‚òÖ</span>
                        <span>Climate & Water</span>
                    </div>
                    <div class="legend-item">
                        <span style="color: #e74c3c; font-size: 16px;">üõ°Ô∏è ‚¨¢</span>
                        <span>Disaster Risk</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>üî• Heatmap Analysis</h3>
                <button class="btn" onclick="generateHeatmapAnalysis()" style="background: #e74c3c; color: white; margin-bottom: 10px;">
                    üî• Generate Heatmap Analysis
                </button>
                
                <button class="btn" onclick="toggleTransmissionLines()" style="background: #f39c12; color: white; margin-bottom: 10px;">
                    ‚ö° Toggle Transmission Lines
                </button>
                
                <button class="btn" onclick="clearAllAnalysis()" style="background: #95a5a6; color: white;">
                    üóëÔ∏è Clear Analysis
                </button>
            </div>

            <div class="section">
                <h3>üî• Heatmap Criteria Weights</h3>
                <div class="weight-control">
                    <label>üë• User Demographics:</label>
                    <input type="range" id="demographics-weight" min="0" max="0.5" step="0.05" value="0.20" onchange="updateHeatmapWeights()">
                    <span id="demographics-weight-value">20%</span>
                </div>
                <div class="weight-control">
                    <label>üåê Network Infrastructure:</label>
                    <input type="range" id="network-weight" min="0" max="0.5" step="0.05" value="0.25" onchange="updateHeatmapWeights()">
                    <span id="network-weight-value">25%</span>
                </div>
                <div class="weight-control">
                    <label>‚ö° Energy Grid:</label>
                    <input type="range" id="energy-weight" min="0" max="0.5" step="0.05" value="0.20" onchange="updateHeatmapWeights()">
                    <span id="energy-weight-value">20%</span>
                </div>
                <div class="weight-control">
                    <label>üîã Renewable Energy:</label>
                    <input type="range" id="renewable-weight" min="0" max="0.3" step="0.05" value="0.10" onchange="updateHeatmapWeights()">
                    <span id="renewable-weight-value">10%</span>
                </div>
                <div class="weight-control">
                    <label>üå°Ô∏è Climate & Water:</label>
                    <input type="range" id="climate-weight" min="0" max="0.3" step="0.05" value="0.15" onchange="updateHeatmapWeights()">
                    <span id="climate-weight-value">15%</span>
                </div>
                <div class="weight-control">
                    <label>üõ°Ô∏è Disaster Risk:</label>
                    <input type="range" id="disaster-weight" min="0" max="0.3" step="0.05" value="0.10" onchange="updateHeatmapWeights()">
                    <span id="disaster-weight-value">10%</span>
                </div>
                <button class="btn" onclick="resetHeatmapWeights()" style="margin-top: 10px;">üîÑ Reset Weights</button>
            </div>

            <div class="section">
                <h3>‚öôÔ∏è Analysis Parameters</h3>
                <label>Power Infrastructure Weight:</label>
                <input type="range" id="power-weight" min="0" max="1" step="0.05" value="0.25">
                <span id="power-weight-value">25%</span>

                <label>Telecommunications Weight:</label>
                <input type="range" id="connectivity-weight" min="0" max="1" step="0.05" value="0.20">
                <span id="connectivity-weight-value">20%</span>

                <label>Climate/Cooling Weight:</label>
                <input type="range" id="cooling-weight" min="0" max="1" step="0.05" value="0.15">
                <span id="cooling-weight-value">15%</span>

                <label>Water Supply Weight:</label>
                <input type="range" id="water-weight" min="0" max="1" step="0.05" value="0.12">
                <span id="water-weight-value">12%</span>

                <label>Transportation Weight:</label>
                <input type="range" id="transport-weight" min="0" max="1" step="0.05" value="0.10">
                <span id="transport-weight-value">10%</span>

                <label>Geological Stability Weight:</label>
                <input type="range" id="geology-weight" min="0" max="1" step="0.05" value="0.08">
                <span id="geology-weight-value">8%</span>

                <label>Security Weight:</label>
                <input type="range" id="security-weight" min="0" max="1" step="0.05" value="0.05">
                <span id="security-weight-value">5%</span>

                <label>Regulatory Weight:</label>
                <input type="range" id="regulatory-weight" min="0" max="1" step="0.05" value="0.05">
                <span id="regulatory-weight-value">5%</span>

                <hr style="margin: 15px 0;">
                
                <label>Analysis Grid Resolution:</label>
                <select id="grid-resolution">
                    <option value="0.1">High (0.1¬∞)</option>
                    <option value="0.25" selected>Medium (0.25¬∞)</option>
                    <option value="0.5">Low (0.5¬∞)</option>
                </select>

                <label>Search Radius (km):</label>
                <input type="range" id="search-radius" min="1" max="100" value="50">
                <span id="radius-value">50</span> km

                <button class="btn" onclick="resetDefaultWeights()">üîÑ Reset Default Weights</button>
            </div>
        </div>

        <div class="main-content">
            <div id="map"></div>
            
            <div class="info-panel" id="info-panel" style="display: none;">
                <h4>üìç Location Info</h4>
                <div id="location-details"></div>
            </div>

            <div class="legend">
                <h4>Legend</h4>
                <div class="legend-item">
                    <div class="legend-color score-high"></div>
                    <span>High Suitability</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color score-medium"></div>
                    <span>Medium Suitability</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color score-low"></div>
                    <span>Low Suitability</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script src="datacenter-data-fetcher.js"></script>
    <script src="heatmap-analyzer.js"></script>
    <script>
        // Initialize map centered on Australia
        const map = L.map('map').setView([-25.2744, 133.7751], 5);

        // Add base map
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Layer groups for different data types (simplified)
        const layers = {
            userDemographics: L.layerGroup(),
            networkInfrastructure: L.layerGroup(),
            energyGrid: L.layerGroup(),
            renewableEnergy: L.layerGroup(),
            climateWater: L.layerGroup(),
            disasterRisk: L.layerGroup(),
            analysis: L.layerGroup(),
            transmissionLines: L.layerGroup()
        };

        // Add only the analysis layer by default (start clean)
        layers.analysis.addTo(map);

        // Data storage for the 6 specialized categories
        let dataCenterData = {
            userDemographics: null,
            networkInfrastructure: null,
            energyGrid: null,
            renewableEnergy: null,
            climateWater: null,
            disasterRisk: null
        };

        // Initialize specialized analyzers
        const dataCenterDataFetcher = new DataCenterDataFetcher();
        const heatmapAnalyzer = new DataCenterHeatmapAnalyzer();

        // Load specialized data center analysis data
        async function loadDataCenterData() {
            try {
                showLoadingStatus(true);
                updateLoadingDetails('üîç Fetching User Demographics Data...');
                
                // Fetch all specialized data
                const allData = await dataCenterDataFetcher.fetchAllDataCenterData();
                
                // Process and visualize each data category
                for (const [category, data] of Object.entries(allData)) {
                    updateLoadingDetails(`üìä Processing ${dataCenterDataFetcher.dataCategories[category]}...`);
                    
                    // Store the data
                    dataCenterData[category] = data;
                    
                    // Visualize on map
                    visualizeDataCategory(data, category);
                    
                    await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for visual effect
                }
                
                updateLoadingDetails('‚úÖ All data loaded successfully!');
                
                setTimeout(() => {
                    showLoadingStatus(false);
                    showDataLoadedNotification();
                }, 1500);
                
            } catch (error) {
                console.error('Error loading data center data:', error);
                updateLoadingDetails('‚ùå Error loading data: ' + error.message);
                setTimeout(() => showLoadingStatus(false), 3000);
            }
        }

        // Visualize data category on map with specialized markers
        function visualizeDataCategory(data, category) {
            const categoryConfig = {
                userDemographics: { color: '#3498db', icon: 'üë•', shape: 'circle' },
                networkInfrastructure: { color: '#9b59b6', icon: 'üåê', shape: 'square' },
                energyGrid: { color: '#f39c12', icon: '‚ö°', shape: 'triangle' },
                renewableEnergy: { color: '#2ecc71', icon: 'üîã', shape: 'diamond' },
                climateWater: { color: '#1abc9c', icon: 'üå°Ô∏è', shape: 'star' },
                disasterRisk: { color: '#e74c3c', icon: 'üõ°Ô∏è', shape: 'hexagon' }
            };

            const config = categoryConfig[category];
            if (!config || !data || !data.features) return;

            // Clear existing layer
            layers[category].clearLayers();

            // Add features to map
            data.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    const [lng, lat] = feature.geometry.coordinates;
                    
                    // Create custom marker
                    const markerHtml = `
                        <div style="
                            background-color: ${config.color};
                            color: white;
                            width: 20px;
                            height: 20px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: ${config.shape === 'square' ? '0' : '50%'};
                            border: 2px solid white;
                            font-size: 10px;
                            font-weight: bold;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        ">
                            ${config.icon}
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10],
                        className: 'custom-marker'
                    });
                    
                    const marker = L.marker([lat, lng], { icon: icon });
                    
                    // Create popup content
                    const popupContent = createCategoryPopup(feature.properties, category, config);
                    marker.bindPopup(popupContent);
                    
                    marker.addTo(layers[category]);
                }
            });

            // Add layer to map
            if (!map.hasLayer(layers[category])) {
                layers[category].addTo(map);
            }
        }

        // Create popup content for data categories
        function createCategoryPopup(properties, category, config) {
            const categoryNames = {
                userDemographics: 'User Demographics',
                networkInfrastructure: 'Network Infrastructure',
                energyGrid: 'Energy Grid',
                renewableEnergy: 'Renewable Energy',
                climateWater: 'Climate & Water',
                disasterRisk: 'Natural Disaster Risk'
            };

            let content = `
                <div style="font-family: Arial, sans-serif; max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: ${config.color};">
                        ${config.icon} ${categoryNames[category]}
                    </h4>
            `;

            // Category-specific content
            switch(category) {
                case 'userDemographics':
                    content += `
                        <p><strong>Area:</strong> ${properties.SA2_NAME21 || properties.name || 'N/A'}</p>
                        <p><strong>Population Density:</strong> ${properties.populationDensity?.toFixed(1) || 'N/A'}</p>
                        <p><strong>Target Score:</strong> ${properties.targetScore || 'N/A'}</p>
                    `;
                    break;
                case 'networkInfrastructure':
                    content += `
                        <p><strong>Name:</strong> ${properties.name || 'N/A'}</p>
                        <p><strong>Type:</strong> ${properties.type || 'N/A'}</p>
                        <p><strong>Network Score:</strong> ${properties.networkScore || 'N/A'}</p>
                        ${properties.capacity ? `<p><strong>Capacity:</strong> ${properties.capacity}</p>` : ''}
                    `;
                    break;
                case 'energyGrid':
                    content += `
                        <p><strong>Station:</strong> ${properties.name || 'N/A'}</p>
                        <p><strong>Capacity:</strong> ${properties.capacity || 'N/A'} MW</p>
                        <p><strong>Type:</strong> ${properties.fuelType || 'N/A'}</p>
                        <p><strong>Grid Score:</strong> ${properties.gridScore || 'N/A'}</p>
                    `;
                    break;
                case 'renewableEnergy':
                    content += `
                        <p><strong>Type:</strong> ${properties.renewableType || 'N/A'}</p>
                        <p><strong>Potential:</strong> ${properties.potential || 'N/A'}</p>
                        <p><strong>Capacity Score:</strong> ${properties.capacityScore || 'N/A'}</p>
                    `;
                    break;
                case 'climateWater':
                    content += `
                        <p><strong>Type:</strong> ${properties.type || 'N/A'}</p>
                        ${properties.averageTemp ? `<p><strong>Avg Temp:</strong> ${properties.averageTemp}¬∞C</p>` : ''}
                        ${properties.climateScore ? `<p><strong>Climate Score:</strong> ${properties.climateScore}</p>` : ''}
                        ${properties.waterScore ? `<p><strong>Water Score:</strong> ${properties.waterScore}</p>` : ''}
                    `;
                    break;
                case 'disasterRisk':
                    content += `
                        <p><strong>Hazard:</strong> ${properties.hazardType || 'N/A'}</p>
                        <p><strong>Risk Level:</strong> ${properties.riskLevel || 'N/A'}</p>
                        <p><strong>Safety Score:</strong> ${properties.safetyScore || 'N/A'}</p>
                    `;
                    break;
            }

            content += '</div>';
            return content;
        }

        // Show/hide loading status
        function showLoadingStatus(show) {
            const statusDiv = document.getElementById('data-loading-status');
            if (statusDiv) {
                statusDiv.style.display = show ? 'block' : 'none';
            }
        }

        // Update loading details
        function updateLoadingDetails(message) {
            const detailsDiv = document.getElementById('loading-details');
            if (detailsDiv) {
                detailsDiv.innerHTML = `<small>${message}</small>`;
            }
        }

        // Show data loaded notification
        function showDataLoadedNotification() {
            const totalFeatures = Object.values(dataCenterData)
                .filter(data => data && data.features)
                .reduce((total, data) => total + data.features.length, 0);

            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #27ae60;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">üîç</span>
                    <div>
                        <div>DATA CENTER DATA LOADED</div>
                        <div style="font-size: 12px; opacity: 0.9;">${totalFeatures} data points across 6 categories</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 4000);
        }

        // File upload handlers
        function setupFileUpload(fileId, layerType) {
            const fileInput = document.getElementById(fileId);
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        processFile(file, layerType);
                    }
                });
            }
        }

        // Process uploaded files
        function processFile(file, layerType) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.json') || file.name.endsWith('.geojson')) {
                        data = JSON.parse(e.target.result);
                        addGeoJSONLayer(data, layerType);
                    } else if (file.name.endsWith('.csv')) {
                        data = parseCSV(e.target.result);
                        addCSVLayer(data, layerType);
                    }
                    
                    uploadedData[layerType] = data;
                    updateLayerControls();
                    
                } catch (error) {
                    alert('Error processing file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }

        // Add GeoJSON layer to map with distinct visual indicators
        function addGeoJSONLayer(data, layerType) {
            const layerConfig = {
                roads: {
                    color: '#2980b9',
                    icon: 'üõ£Ô∏è',
                    shape: 'line',
                    radius: 6,
                    symbol: '‚óè'
                },
                electricity: {
                    color: '#f39c12',
                    icon: '‚ö°',
                    shape: 'square',
                    radius: 8,
                    symbol: '‚ñ†'
                },
                telecommunications: {
                    color: '#9b59b6',
                    icon: 'üì°',
                    shape: 'triangle',
                    radius: 10,
                    symbol: '‚ñ≤'
                },
                water: {
                    color: '#3498db',
                    icon: 'üíß',
                    shape: 'diamond',
                    radius: 7,
                    symbol: '‚ô¶'
                },
                climate: {
                    color: '#e74c3c',
                    icon: 'üå°Ô∏è',
                    shape: 'star',
                    radius: 9,
                    symbol: '‚òÖ'
                },
                geology: {
                    color: '#2ecc71',
                    icon: 'üèîÔ∏è',
                    shape: 'hexagon',
                    radius: 8,
                    symbol: '‚¨¢'
                }
            };

            const config = layerConfig[layerType];
            
            // Clear existing layer
            layers[layerType].clearLayers();
            
            // Create custom icon for markers
            function createCustomMarker(latlng, feature) {
                const markerHtml = `
                    <div style="
                        background-color: ${config.color};
                        color: white;
                        width: ${config.radius * 3}px;
                        height: ${config.radius * 3}px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: ${config.shape === 'square' ? '0' : '50%'};
                        border: 2px solid white;
                        font-size: 12px;
                        font-weight: bold;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        ${config.shape === 'triangle' ? 'clip-path: polygon(50% 0%, 0% 100%, 100% 100%);' : ''}
                        ${config.shape === 'diamond' ? 'transform: rotate(45deg);' : ''}
                        ${config.shape === 'star' ? 'clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);' : ''}
                        ${config.shape === 'hexagon' ? 'clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);' : ''}
                    ">
                        ${config.icon}
                    </div>
                `;
                
                const icon = L.divIcon({
                    html: markerHtml,
                    iconSize: [config.radius * 3, config.radius * 3],
                    iconAnchor: [config.radius * 1.5, config.radius * 1.5],
                    className: 'custom-marker'
                });
                
                return L.marker(latlng, { icon: icon });
            }
            
            // Add layer with custom styling
            const layer = L.geoJSON(data, {
                style: {
                    color: config.color,
                    weight: 3,
                    opacity: 0.8,
                    fillColor: config.color,
                    fillOpacity: 0.3
                },
                pointToLayer: function(feature, latlng) {
                    return createCustomMarker(latlng, feature);
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties) {
                        const popupContent = `
                            <div style="font-family: Arial, sans-serif;">
                                <h4 style="margin: 0 0 10px 0; color: ${config.color};">
                                    ${config.icon} ${layerType.toUpperCase()} Data
                                </h4>
                                ${createPopupContent(feature.properties, layerType)}
                            </div>
                        `;
                        layer.bindPopup(popupContent);
                    }
                }
            }).addTo(layers[layerType]);

            // Add the layer to map and show notification
            if (!map.hasLayer(layers[layerType])) {
                layers[layerType].addTo(map);
            }
            
            // Show data loading notification
            showDataLoadedNotification(layerType, data.features ? data.features.length : 0, config);

            // Fit map to data bounds if it's the first layer with actual data
            const layersWithData = Object.keys(uploadedData).filter(key => uploadedData[key]);
            if (layersWithData.length === 1) {
                const bounds = L.geoJSON(data).getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds);
                }
            }
        }

        // Show data loaded notification
        function showDataLoadedNotification(layerType, featureCount, config) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${config.color};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">${config.icon}</span>
                    <div>
                        <div>${layerType.toUpperCase()} DATA LOADED</div>
                        <div style="font-size: 12px; opacity: 0.9;">${featureCount} features ‚Ä¢ ${config.symbol} markers</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 3000);
        }

        // Reset map to clean state
        function resetMap() {
            // Clear all layers
            Object.values(layers).forEach(layer => {
                layer.clearLayers();
            });
            
            // Reset uploaded data
            uploadedData = {
                roads: null,
                electricity: null,
                telecommunications: null,
                water: null,
                climate: null,
                geology: null
            };
            
            // Remove layers from map
            Object.values(layers).forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            
            // Re-add only analysis layer
            layers.analysis.addTo(map);
            
            // Reset map view to Australia
            map.setView([-25.2744, 133.7751], 5);
            
            // Clear analysis results
            const resultsDiv = document.getElementById('analysis-results');
            if (resultsDiv) {
                resultsDiv.style.display = 'none';
            }
            
            // Reset layer toggles
            Object.keys(layers).forEach(layerType => {
                const toggle = document.getElementById(`${layerType}-toggle`);
                if (toggle) {
                    toggle.checked = false;
                }
            });
            
            // Show reset notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc3545;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">üóëÔ∏è</span>
                    <div>MAP RESET TO CLEAN STATE</div>
                </div>
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        // Parse CSV data
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = lines[i].split(',');
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].trim() : '';
                    });
                    data.push(row);
                }
            }
            return data;
        }

        // Add CSV layer as points using new visual system
        function addCSVLayer(data, layerType) {
            // Convert CSV data to GeoJSON format
            const features = [];
            
            data.forEach(row => {
                let lat, lng;
                
                // Try to find lat/lng columns with various names
                const latKeys = ['lat', 'latitude', 'y', 'Latitude', 'LAT'];
                const lngKeys = ['lng', 'lon', 'longitude', 'x', 'Longitude', 'LON'];
                
                for (let key of latKeys) {
                    if (row[key]) lat = parseFloat(row[key]);
                }
                for (let key of lngKeys) {
                    if (row[key]) lng = parseFloat(row[key]);
                }

                if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                    features.push({
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [lng, lat]
                        },
                        properties: row
                    });
                }
            });

            const geoJsonData = {
                type: "FeatureCollection",
                features: features
            };

            // Use the enhanced GeoJSON layer function
            addGeoJSONLayer(geoJsonData, layerType);
        }

        // Create popup content
        function createPopupContent(properties, layerType) {
            let content = `<strong>${layerType.toUpperCase()} Infrastructure</strong><br>`;
            for (let key in properties) {
                if (properties[key]) {
                    content += `<strong>${key}:</strong> ${properties[key]}<br>`;
                }
            }
            return content;
        }

        // Load sample data for demonstration
        function loadSampleData() {
            // Clear existing layers
            Object.values(layers).forEach(layer => {
                if (layer !== layers.analysis) layer.clearLayers();
            });

            // Load all sample datasets
            const datasets = [
                'electricityGrid', 'telecommunications', 'waterSupply', 
                'transport', 'climate', 'geology'
            ];

            datasets.forEach(datasetName => {
                const data = dataSourceManager.getSampleDataset(datasetName);
                if (data) {
                    const layerType = datasetName === 'electricityGrid' ? 'electricity' :
                                     datasetName === 'waterSupply' ? 'water' :
                                     datasetName === 'transport' ? 'roads' :
                                     datasetName;
                    
                    addGeoJSONLayer(data, layerType);
                    uploadedData[layerType] = data;
                }
            });

            alert('Sample Australian infrastructure data loaded! You can now perform advanced analysis.');
        }

        // Load government datasets
        function loadGovernmentData() {
            const sources = dataSourceManager.getAvailableDataSources();
            let message = 'Available Australian Government Data Sources:\n\n';
            
            sources.forEach(source => {
                message += `‚Ä¢ ${source.name}\n  ${source.description}\n\n`;
            });
            
            message += 'Note: This demo uses sample data. In production, this would fetch real government datasets via APIs.';
            alert(message);
            
            // For demo, load sample data
            loadSampleData();
        }

        // Advanced suitability analysis
        function performAdvancedSuitabilityAnalysis() {
            const resultsDiv = document.getElementById('analysis-results');
            const resultsContent = document.getElementById('results-content');
            
            // Clear previous analysis
            layers.analysis.clearLayers();
            currentAnalysisResults = [];
            
            // Get current weights from UI
            updateAnalysisWeights();
            
            // Get grid resolution
            const gridSize = parseFloat(document.getElementById('grid-resolution').value);
            
            // Generate analysis grid
            const bounds = map.getBounds();
            let analysisCount = 0;
            const maxAnalyses = 200; // Limit for performance
            
            resultsContent.innerHTML = '<p>üîç Running advanced suitability analysis...</p>';
            resultsDiv.style.display = 'block';
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                for (let lat = bounds.getSouth(); lat < bounds.getNorth() && analysisCount < maxAnalyses; lat += gridSize) {
                    for (let lng = bounds.getWest(); lng < bounds.getEast() && analysisCount < maxAnalyses; lng += gridSize) {
                        analysisCount++;
                        
                        const analysis = suitabilityAnalyzer.analyzeLocation(lat, lng, uploadedData);
                        currentAnalysisResults.push(analysis);
                        
                        let color, className;
                        const score = analysis.overallScore;
                        
                        if (score > 0.8) {
                            color = '#27ae60';
                            className = 'score-high';
                        } else if (score > 0.6) {
                            color = '#f39c12';
                            className = 'score-medium';
                        } else if (score > 0.4) {
                            color = '#e67e22';
                            className = 'score-medium';
                        } else {
                            color = '#e74c3c';
                            className = 'score-low';
                        }
                        
                        const rectangle = L.rectangle([
                            [lat, lng],
                            [lat + gridSize, lng + gridSize]
                        ], {
                            color: color,
                            fillColor: color,
                            fillOpacity: 0.6,
                            weight: 1
                        });
                        
                        rectangle.bindPopup(createDetailedAnalysisPopup(analysis));
                        rectangle.addTo(layers.analysis);
                    }
                }
                
                // Sort results by score
                currentAnalysisResults.sort((a, b) => b.overallScore - a.overallScore);
                
                // Display results
                displayAnalysisResults();
                
            }, 100);
        }

        // Create detailed analysis popup
        function createDetailedAnalysisPopup(analysis) {
            const { overallScore, detailedScores, suitabilityLevel, riskFactors } = analysis;
            
            let popup = `
                <div style="max-width: 300px;">
                    <h4>üìç Detailed Site Analysis</h4>
                    <p><strong>Location:</strong> ${analysis.coordinates.lat.toFixed(3)}, ${analysis.coordinates.lng.toFixed(3)}</p>
                    <p><strong>Overall Score:</strong> <span class="score-indicator ${getSuitabilityClass(overallScore)}">${(overallScore * 100).toFixed(1)}%</span></p>
                    <p><strong>Suitability:</strong> ${suitabilityLevel.level}</p>
                    
                    <h5>Factor Scores:</h5>
                    <ul style="font-size: 12px;">
                        <li>Power: ${(detailedScores.power.score * 100).toFixed(0)}%</li>
                        <li>Connectivity: ${(detailedScores.connectivity.score * 100).toFixed(0)}%</li>
                        <li>Cooling: ${(detailedScores.cooling.score * 100).toFixed(0)}%</li>
                        <li>Water: ${(detailedScores.water.score * 100).toFixed(0)}%</li>
                        <li>Transport: ${(detailedScores.transport.score * 100).toFixed(0)}%</li>
                        <li>Geology: ${(detailedScores.geology.score * 100).toFixed(0)}%</li>
                        <li>Security: ${(detailedScores.security.score * 100).toFixed(0)}%</li>
                        <li>Regulatory: ${(detailedScores.regulations.score * 100).toFixed(0)}%</li>
                    </ul>
            `;
            
            if (riskFactors.length > 0) {
                popup += `<h5>‚ö†Ô∏è Risk Factors:</h5><ul style="font-size: 11px;">`;
                riskFactors.forEach(risk => {
                    popup += `<li>${risk.factor}: ${risk.description}</li>`;
                });
                popup += '</ul>';
            }
            
            popup += '</div>';
            return popup;
        }

        // Display analysis results
        function displayAnalysisResults() {
            const resultsContent = document.getElementById('results-content');
            const topSites = currentAnalysisResults.slice(0, 5);
            
            let html = `
                <h4>‚úÖ Analysis Complete!</h4>
                <p><strong>Total Sites Analyzed:</strong> ${currentAnalysisResults.length}</p>
                <p><strong>Grid Resolution:</strong> ${document.getElementById('grid-resolution').value}¬∞</p>
                
                <h5>üèÜ Top 5 Locations:</h5>
                <ol>
            `;
            
            topSites.forEach((site, index) => {
                html += `
                    <li>
                        <strong>Score: ${(site.overallScore * 100).toFixed(1)}%</strong><br>
                        <small>Lat: ${site.coordinates.lat.toFixed(3)}, Lng: ${site.coordinates.lng.toFixed(3)}</small><br>
                        <small>${site.suitabilityLevel.level} - ${site.suitabilityLevel.description}</small>
                    </li>
                `;
            });
            
            html += `
                </ol>
                <button class="btn" onclick="showTopSites()">üìç Highlight Top Sites</button>
                <button class="btn" onclick="generateDetailedReport()">üìä Generate Report</button>
            `;
            
            resultsContent.innerHTML = html;
        }

        // Find optimal locations
        function findOptimalLocations() {
            if (currentAnalysisResults.length === 0) {
                alert('Please run the Advanced Suitability Analysis first!');
                return;
            }
            
            showTopSites();
        }

        // Show top sites on map
        function showTopSites() {
            const topSites = currentAnalysisResults.slice(0, 5);
            
            // Clear existing markers
            layers.analysis.eachLayer(layer => {
                if (layer.options && layer.options.isTopSite) {
                    layers.analysis.removeLayer(layer);
                }
            });
            
            // Add markers for top sites
            topSites.forEach((site, index) => {
                const marker = L.marker([site.coordinates.lat, site.coordinates.lng], {
                    isTopSite: true
                }).addTo(layers.analysis);
                
                marker.bindPopup(`
                    <h4>üèÜ Rank #${index + 1} Site</h4>
                    ${createDetailedAnalysisPopup(site)}
                `);
                
                // Auto-open popup for #1 site
                if (index === 0) {
                    marker.openPopup();
                }
            });
            
            // Fit map to show top sites
            if (topSites.length > 0) {
                const group = new L.featureGroup(
                    topSites.map(site => L.marker([site.coordinates.lat, site.coordinates.lng]))
                );
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        // Generate comparative report
        function generateComparativeReport() {
            if (currentAnalysisResults.length === 0) {
                alert('Please run the Advanced Suitability Analysis first!');
                return;
            }
            
            const topSites = currentAnalysisResults.slice(0, 10);
            let report = 'Data Center Location Analysis Report\\n';
            report += '='.repeat(50) + '\\n\\n';
            
            report += `Analysis Summary:\\n`;
            report += `- Total locations analyzed: ${currentAnalysisResults.length}\\n`;
            report += `- Analysis date: ${new Date().toLocaleDateString()}\\n`;
            report += `- Best overall score: ${(currentAnalysisResults[0].overallScore * 100).toFixed(1)}%\\n\\n`;
            
            report += 'Top 10 Recommended Locations:\\n';
            report += '-'.repeat(40) + '\\n';
            
            topSites.forEach((site, index) => {
                report += `${index + 1}. Location: ${site.coordinates.lat.toFixed(3)}, ${site.coordinates.lng.toFixed(3)}\\n`;
                report += `   Overall Score: ${(site.overallScore * 100).toFixed(1)}%\\n`;
                report += `   Level: ${site.suitabilityLevel.level}\\n`;
                report += `   Key Strengths: `;
                
                // Find top 3 scoring factors
                const factorScores = Object.entries(site.detailedScores)
                    .map(([factor, data]) => ({ factor, score: data.score }))
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 3);
                
                report += factorScores.map(f => `${f.factor} (${(f.score * 100).toFixed(0)}%)`).join(', ');
                report += '\\n\\n';
            });
            
            // Create downloadable report
            const blob = new Blob([report], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `data-center-analysis-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            alert('Comparative report generated and downloaded!');
        }

        // Perform risk assessment
        function performRiskAssessment() {
            if (currentAnalysisResults.length === 0) {
                alert('Please run the Advanced Suitability Analysis first!');
                return;
            }
            
            const allRisks = [];
            currentAnalysisResults.forEach(result => {
                result.riskFactors.forEach(risk => {
                    const existing = allRisks.find(r => r.factor === risk.factor);
                    if (existing) {
                        existing.count++;
                    } else {
                        allRisks.push({ ...risk, count: 1 });
                    }
                });
            });
            
            // Sort by frequency
            allRisks.sort((a, b) => b.count - a.count);
            
            let riskReport = 'Risk Assessment Summary\\n';
            riskReport += '='.repeat(30) + '\\n\\n';
            riskReport += 'Most Common Risk Factors:\\n';
            
            allRisks.slice(0, 10).forEach((risk, index) => {
                const percentage = (risk.count / currentAnalysisResults.length * 100).toFixed(1);
                riskReport += `${index + 1}. ${risk.factor} (${risk.severity} Risk)\\n`;
                riskReport += `   Affects ${percentage}% of analyzed locations\\n`;
                riskReport += `   Description: ${risk.description}\\n\\n`;
            });
            
            alert(riskReport);
        }

        // Helper functions
        function getSuitabilityClass(score) {
            if (score > 0.8) return 'score-high';
            if (score > 0.6) return 'score-medium';
            return 'score-low';
        }

        function updateAnalysisWeights() {
            const weights = {
                power: parseFloat(document.getElementById('power-weight').value),
                connectivity: parseFloat(document.getElementById('connectivity-weight').value),
                cooling: parseFloat(document.getElementById('cooling-weight').value),
                water: parseFloat(document.getElementById('water-weight').value),
                transport: parseFloat(document.getElementById('transport-weight').value),
                geology: parseFloat(document.getElementById('geology-weight').value),
                security: parseFloat(document.getElementById('security-weight').value),
                regulations: parseFloat(document.getElementById('regulatory-weight').value)
            };
            
            suitabilityAnalyzer.updateWeights(weights);
        }

        function resetDefaultWeights() {
            document.getElementById('power-weight').value = 0.25;
            document.getElementById('connectivity-weight').value = 0.20;
            document.getElementById('cooling-weight').value = 0.15;
            document.getElementById('water-weight').value = 0.12;
            document.getElementById('transport-weight').value = 0.10;
            document.getElementById('geology-weight').value = 0.08;
            document.getElementById('security-weight').value = 0.05;
            document.getElementById('regulatory-weight').value = 0.05;
            
            updateWeightDisplays();
        }

        function updateWeightDisplays() {
            document.getElementById('power-weight-value').textContent = (parseFloat(document.getElementById('power-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('connectivity-weight-value').textContent = (parseFloat(document.getElementById('connectivity-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('cooling-weight-value').textContent = (parseFloat(document.getElementById('cooling-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('water-weight-value').textContent = (parseFloat(document.getElementById('water-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('transport-weight-value').textContent = (parseFloat(document.getElementById('transport-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('geology-weight-value').textContent = (parseFloat(document.getElementById('geology-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('security-weight-value').textContent = (parseFloat(document.getElementById('security-weight').value) * 100).toFixed(0) + '%';
            document.getElementById('regulatory-weight-value').textContent = (parseFloat(document.getElementById('regulatory-weight').value) * 100).toFixed(0) + '%';
        }

        function generateDetailedReport() {
            if (currentAnalysisResults.length === 0) {
                alert('No analysis results available!');
                return;
            }
            
            const topSite = currentAnalysisResults[0];
            let report = `DETAILED SITE ANALYSIS REPORT\\n`;
            report += `${'='.repeat(50)}\\n\\n`;
            report += `Location: ${topSite.coordinates.lat.toFixed(4)}, ${topSite.coordinates.lng.toFixed(4)}\\n`;
            report += `Overall Suitability Score: ${(topSite.overallScore * 100).toFixed(1)}%\\n`;
            report += `Suitability Level: ${topSite.suitabilityLevel.level}\\n`;
            report += `Assessment: ${topSite.suitabilityLevel.description}\\n\\n`;
            
            report += `DETAILED FACTOR ANALYSIS:\\n`;
            report += `${'-'.repeat(30)}\\n`;
            
            Object.entries(topSite.detailedScores).forEach(([factor, data]) => {
                report += `\\n${factor.toUpperCase()}:\\n`;
                report += `Score: ${(data.score * 100).toFixed(1)}%\\n`;
                report += `Factors:\\n`;
                data.factors.forEach(f => report += `  ‚Ä¢ ${f}\\n`);
                
                if (data.details) {
                    report += `Details:\\n`;
                    Object.entries(data.details).forEach(([key, value]) => {
                        report += `  ${key}: ${value}\\n`;
                    });
                }
            });
            
            if (topSite.recommendations.length > 0) {
                report += `\\nRECOMMENDATIONS:\\n`;
                report += `${'-'.repeat(20)}\\n`;
                topSite.recommendations.forEach((rec, index) => {
                    report += `\\n${index + 1}. ${rec.category} (${rec.priority} Priority)\\n`;
                    report += `   ${rec.recommendation}\\n`;
                    report += `   Estimated Cost: ${rec.estimatedCost}\\n`;
                });
            }
            
            if (topSite.riskFactors.length > 0) {
                report += `\\nRISK FACTORS:\\n`;
                report += `${'-'.repeat(15)}\\n`;
                topSite.riskFactors.forEach((risk, index) => {
                    report += `\\n${index + 1}. ${risk.factor} (${risk.severity} Risk)\\n`;
                    report += `   ${risk.description}\\n`;
                });
            }
            
            // Download report
            const blob = new Blob([report], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `detailed-site-analysis-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Generate buffer zones
        function generateBuffer() {
            const radius = parseInt(document.getElementById('search-radius').value) * 1000; // Convert to meters
            
            // Create buffers around existing infrastructure
            layers.analysis.clearLayers();
            
            layers.roads.eachLayer(layer => {
                if (layer.getLatLng) {
                    L.circle(layer.getLatLng(), {
                        radius: radius,
                        color: '#2980b9',
                        fillOpacity: 0.1,
                        weight: 1
                    }).addTo(layers.analysis);
                }
            });
            
            alert(`Generated ${radius/1000}km proximity zones around infrastructure.`);
        }

        // Clear analysis
        function clearAnalysis() {
            layers.analysis.clearLayers();
            document.getElementById('analysis-results').style.display = 'none';
        }

        // Update layer controls
        function updateLayerControls() {
            const layerTypes = ['roads', 'electricity', 'telecommunications', 'water', 'climate', 'geology'];
            
            layerTypes.forEach(type => {
                const toggle = document.getElementById(`${type}-toggle`);
                const opacity = document.getElementById(`${type}-opacity`);
                
                if (toggle) {
                    toggle.addEventListener('change', function() {
                        if (this.checked) {
                            map.addLayer(layers[type]);
                        } else {
                            map.removeLayer(layers[type]);
                        }
                    });
                }
                
                if (opacity) {
                    opacity.addEventListener('input', function() {
                        layers[type].eachLayer(layer => {
                            if (layer.setStyle) {
                                layer.setStyle({opacity: this.value, fillOpacity: this.value});
                            }
                        });
                    });
                }
            });
        }

        // Weight sliders event listeners
        function setupWeightSliders() {
            const weightIds = [
                'power-weight', 'connectivity-weight', 'cooling-weight', 'water-weight',
                'transport-weight', 'geology-weight', 'security-weight', 'regulatory-weight'
            ];
            
            weightIds.forEach(id => {
                const slider = document.getElementById(id);
                if (slider) {
                    slider.addEventListener('input', function() {
                        updateWeightDisplays();
                    });
                }
            });
            
            // Search radius slider
            const radiusSlider = document.getElementById('search-radius');
            if (radiusSlider) {
                radiusSlider.addEventListener('input', function() {
                    document.getElementById('radius-value').textContent = this.value;
                });
            }
        }

        // Initialize file uploads
        function initializeFileUploads() {
            const fileTypes = ['roads', 'electricity', 'telecom', 'water', 'climate', 'geology'];
            
            fileTypes.forEach(type => {
                const layerType = type === 'telecom' ? 'telecommunications' : type;
                setupFileUpload(`${type}-file`, layerType);
            });
        }

        // Initialize drag and drop
        function initializeDragAndDrop() {
            const fileInputs = ['roads-file', 'electricity-file', 'telecom-file', 'water-file', 'climate-file', 'geology-file'];
            
            fileInputs.forEach(fileId => {
                const fileInput = document.getElementById(fileId);
                if (fileInput) {
                    const uploadArea = fileInput.parentElement;
                    
                    uploadArea.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        this.classList.add('dragover');
                    });

                    uploadArea.addEventListener('dragleave', function(e) {
                        e.preventDefault();
                        this.classList.remove('dragover');
                    });

                    uploadArea.addEventListener('drop', function(e) {
                        e.preventDefault();
                        this.classList.remove('dragover');
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            const layerType = fileId.split('-')[0];
                            const mappedType = layerType === 'telecom' ? 'telecommunications' : layerType;
                            processFile(files[0], mappedType);
                        }
                    });
                }
            });
        }

        // Generate heatmap analysis with the loaded data center data
        async function generateHeatmapAnalysis() {
            // Check if any data is loaded
            const hasData = Object.values(dataCenterData).some(data => data !== null);
            
            if (!hasData) {
                alert('‚ö†Ô∏è Please load data first!\n\nClick "üîç Load Data Center Analysis Data" to fetch the specialized datasets needed for heatmap analysis.');
                return;
            }

            // Show progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.id = 'heatmap-progress';
            progressDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                text-align: center;
                min-width: 300px;
            `;
            
            progressDiv.innerHTML = `
                <h3 style="color: #e74c3c; margin: 0 0 15px 0;">üî• Generating Heatmap</h3>
                <div style="width: 100%; height: 6px; background: #ddd; border-radius: 3px; margin: 15px 0;">
                    <div id="heatmap-progress-bar" style="width: 0%; height: 100%; background: #e74c3c; border-radius: 3px; transition: width 0.3s;"></div>
                </div>
                <p id="heatmap-status">Initializing analysis...</p>
                <small style="color: #666;">This may take a few moments...</small>
            `;
            
            document.body.appendChild(progressDiv);
            
            try {
                // Update progress
                updateHeatmapProgress(20, 'Creating analysis grid...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateHeatmapProgress(40, 'Analyzing user demographics...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateHeatmapProgress(60, 'Evaluating infrastructure...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateHeatmapProgress(80, 'Processing risk factors...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateHeatmapProgress(90, 'Generating visualization...');
                
                // Run the actual heatmap analysis with the new data structure
                const results = await heatmapAnalyzer.generateHeatmap(dataCenterData);
                
                updateHeatmapProgress(100, 'Analysis complete!');
                
                // Remove progress indicator after a short delay
                setTimeout(() => {
                    if (progressDiv.parentNode) {
                        progressDiv.parentNode.removeChild(progressDiv);
                    }
                }, 1500);
                
            } catch (error) {
                console.error('Heatmap analysis error:', error);
                alert('‚ùå Error generating heatmap: ' + error.message);
                
                if (progressDiv.parentNode) {
                    progressDiv.parentNode.removeChild(progressDiv);
                }
            }
        }

        // Reset map to clean state
        function resetMap() {
            // Clear all layers
            Object.values(layers).forEach(layer => {
                layer.clearLayers();
            });
            
            // Reset data
            dataCenterData = {
                userDemographics: null,
                networkInfrastructure: null,
                energyGrid: null,
                renewableEnergy: null,
                climateWater: null,
                disasterRisk: null
            };
            
            // Remove layers from map
            Object.values(layers).forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            
            // Re-add only analysis layer
            layers.analysis.addTo(map);
            
            // Clear heatmap
            heatmapAnalyzer.clearHeatmap();
            
            // Reset map view to Australia
            map.setView([-25.2744, 133.7751], 5);
            
            // Hide loading status
            showLoadingStatus(false);
            
            // Show reset notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc3545;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">üóëÔ∏è</span>
                    <div>MAP RESET TO CLEAN STATE</div>
                </div>
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        function updateHeatmapProgress(percentage, status) {
            const progressBar = document.getElementById('heatmap-progress-bar');
            const statusText = document.getElementById('heatmap-status');
            
            if (progressBar) progressBar.style.width = percentage + '%';
            if (statusText) statusText.textContent = status;
        }

        function clearAllAnalysis() {
            // Clear heatmap
            heatmapAnalyzer.clearHeatmap();
            
            // Show confirmation
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #95a5a6;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">üóëÔ∏è</span>
                    <div>HEATMAP ANALYSIS CLEARED</div>
                </div>
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        function toggleTransmissionLines() {
            if (map.hasLayer(layers.transmissionLines)) {
                // Remove transmission lines
                map.removeLayer(layers.transmissionLines);
                showNotification('‚ö° TRANSMISSION LINES HIDDEN', '#f39c12');
            } else {
                // Add transmission lines
                generateTransmissionLines();
                map.addLayer(layers.transmissionLines);
                showNotification('‚ö° TRANSMISSION LINES DISPLAYED', '#f39c12');
            }
        }

        function generateTransmissionLines() {
            // Clear existing lines
            layers.transmissionLines.clearLayers();
            
            // Major power stations and their interconnections
            const powerStations = [
                // NSW
                { name: 'Eraring', lat: -33.0124, lng: 151.5136, capacity: 2880 },
                { name: 'Vales Point', lat: -33.0667, lng: 151.5167, capacity: 1320 },
                { name: 'Mount Piper', lat: -33.4167, lng: 150.1833, capacity: 1400 },
                { name: 'Bayswater', lat: -32.7333, lng: 150.8333, capacity: 2640 },
                { name: 'Liddell', lat: -32.7, lng: 150.85, capacity: 2000 },
                
                // VIC
                { name: 'Loy Yang A', lat: -38.2667, lng: 146.4167, capacity: 2210 },
                { name: 'Loy Yang B', lat: -38.2833, lng: 146.4333, capacity: 1026 },
                { name: 'Hazelwood', lat: -38.2833, lng: 146.5333, capacity: 1600 },
                { name: 'Yallourn W', lat: -38.1833, lng: 146.4, capacity: 1480 },
                
                // QLD
                { name: 'Stanwell', lat: -23.5833, lng: 150.3167, capacity: 1460 },
                { name: 'Tarong', lat: -26.7667, lng: 152.0167, capacity: 1400 },
                { name: 'Millmerran', lat: -27.8333, lng: 151.7333, capacity: 852 },
                { name: 'Kogan Creek', lat: -27.0, lng: 150.9, capacity: 750 },
                
                // SA
                { name: 'Torrens Island', lat: -34.7833, lng: 138.5167, capacity: 1280 },
                { name: 'Pelican Point', lat: -34.8, lng: 138.5, capacity: 478 },
                
                // WA
                { name: 'Muja', lat: -32.9, lng: 116.0, capacity: 854 },
                { name: 'Cockburn', lat: -32.1, lng: 115.8, capacity: 240 },
                
                // TAS
                { name: 'Bell Bay', lat: -41.1167, lng: 146.8167, capacity: 380 }
            ];

            // Major transmission lines (simplified network)
            const transmissionLines = [
                // NSW Internal
                { from: 'Eraring', to: 'Vales Point', voltage: 500 },
                { from: 'Eraring', to: 'Mount Piper', voltage: 500 },
                { from: 'Mount Piper', to: 'Bayswater', voltage: 500 },
                { from: 'Bayswater', to: 'Liddell', voltage: 500 },
                
                // NSW-VIC Interconnector
                { from: 'Mount Piper', to: 'Loy Yang A', voltage: 500 },
                
                // VIC Internal
                { from: 'Loy Yang A', to: 'Loy Yang B', voltage: 500 },
                { from: 'Loy Yang A', to: 'Hazelwood', voltage: 500 },
                { from: 'Hazelwood', to: 'Yallourn W', voltage: 500 },
                
                // NSW-QLD Interconnector
                { from: 'Bayswater', to: 'Stanwell', voltage: 275 },
                
                // QLD Internal
                { from: 'Stanwell', to: 'Tarong', voltage: 275 },
                { from: 'Tarong', to: 'Millmerran', voltage: 275 },
                { from: 'Millmerran', to: 'Kogan Creek', voltage: 275 },
                
                // VIC-SA Interconnector
                { from: 'Loy Yang A', to: 'Torrens Island', voltage: 275 },
                
                // SA Internal
                { from: 'Torrens Island', to: 'Pelican Point', voltage: 275 },
                
                // WA Internal (isolated grid)
                { from: 'Muja', to: 'Cockburn', voltage: 330 }
            ];

            // Create station markers
            powerStations.forEach(station => {
                const marker = L.circleMarker([station.lat, station.lng], {
                    radius: Math.sqrt(station.capacity / 100) * 2, // Size based on capacity
                    fillColor: '#f39c12',
                    color: '#d35400',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });

                marker.bindPopup(`
                    <div style="font-family: Arial, sans-serif;">
                        <h4 style="margin: 0 0 10px 0; color: #f39c12;">‚ö° ${station.name}</h4>
                        <p><strong>Capacity:</strong> ${station.capacity} MW</p>
                        <p><strong>Type:</strong> Power Station</p>
                    </div>
                `);

                marker.addTo(layers.transmissionLines);
            });

            // Create transmission lines
            transmissionLines.forEach(line => {
                const fromStation = powerStations.find(s => s.name === line.from);
                const toStation = powerStations.find(s => s.name === line.to);

                if (fromStation && toStation) {
                    const color = line.voltage >= 500 ? '#e74c3c' : 
                                 line.voltage >= 330 ? '#f39c12' : '#3498db';
                    const weight = line.voltage >= 500 ? 4 : 
                                  line.voltage >= 330 ? 3 : 2;

                    const transmissionLine = L.polyline([
                        [fromStation.lat, fromStation.lng],
                        [toStation.lat, toStation.lng]
                    ], {
                        color: color,
                        weight: weight,
                        opacity: 0.8,
                        dashArray: '10, 5'
                    });

                    transmissionLine.bindPopup(`
                        <div style="font-family: Arial, sans-serif;">
                            <h4 style="margin: 0 0 10px 0; color: ${color};">‚ö° Transmission Line</h4>
                            <p><strong>From:</strong> ${line.from}</p>
                            <p><strong>To:</strong> ${line.to}</p>
                            <p><strong>Voltage:</strong> ${line.voltage} kV</p>
                        </div>
                    `);

                    transmissionLine.addTo(layers.transmissionLines);
                }
            });
        }

        function showNotification(message, color) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: bold;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div>${message}</div>
                </div>
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        function updateHeatmapWeights() {
            const newWeights = {
                userDemographics: parseFloat(document.getElementById('demographics-weight').value),
                networkInfrastructure: parseFloat(document.getElementById('network-weight').value),
                energyGrid: parseFloat(document.getElementById('energy-weight').value),
                renewableEnergy: parseFloat(document.getElementById('renewable-weight').value),
                climateWater: parseFloat(document.getElementById('climate-weight').value),
                disasterRisk: parseFloat(document.getElementById('disaster-weight').value)
            };
            
            // Update the analyzer
            heatmapAnalyzer.updateCriteriaWeights(newWeights);
            
            // Update display values
            document.getElementById('demographics-weight-value').textContent = (newWeights.userDemographics * 100).toFixed(0) + '%';
            document.getElementById('network-weight-value').textContent = (newWeights.networkInfrastructure * 100).toFixed(0) + '%';
            document.getElementById('energy-weight-value').textContent = (newWeights.energyGrid * 100).toFixed(0) + '%';
            document.getElementById('renewable-weight-value').textContent = (newWeights.renewableEnergy * 100).toFixed(0) + '%';
            document.getElementById('climate-weight-value').textContent = (newWeights.climateWater * 100).toFixed(0) + '%';
            document.getElementById('disaster-weight-value').textContent = (newWeights.disasterRisk * 100).toFixed(0) + '%';
            
            // Show total weight
            const total = Object.values(newWeights).reduce((sum, weight) => sum + weight, 0);
            console.log(`Heatmap criteria weights updated. Total: ${(total * 100).toFixed(0)}%`);
        }

        function resetHeatmapWeights() {
            document.getElementById('demographics-weight').value = 0.20;
            document.getElementById('network-weight').value = 0.25;
            document.getElementById('energy-weight').value = 0.20;
            document.getElementById('renewable-weight').value = 0.10;
            document.getElementById('climate-weight').value = 0.15;
            document.getElementById('disaster-weight').value = 0.10;
            
            updateHeatmapWeights();
        }

        // Initialize when page loads
        updateHeatmapWeights();
    </script>
</body>
</html>